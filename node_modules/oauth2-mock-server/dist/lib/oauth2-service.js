"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuth2Service = void 0;
const node_url_1 = require("node:url");
const node_crypto_1 = require("node:crypto");
const node_events_1 = require("node:events");
const node_assert_1 = require("node:assert");
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const basic_auth_1 = __importDefault(require("basic-auth"));
const helpers_1 = require("./helpers");
const types_1 = require("./types");
const types_internals_1 = require("./types-internals");
const DEFAULT_ENDPOINTS = Object.freeze({
    wellKnownDocument: '/.well-known/openid-configuration',
    token: '/token',
    jwks: '/jwks',
    authorize: '/authorize',
    userinfo: '/userinfo',
    revoke: '/revoke',
    endSession: '/endsession',
    introspect: '/introspect',
});
class OAuth2Service extends node_events_1.EventEmitter {
    #issuer;
    #requestHandler;
    #nonce;
    #codeChallenges;
    #endpoints;
    constructor(oauth2Issuer, endpoints) {
        super();
        this.#issuer = oauth2Issuer;
        this.#endpoints = { ...DEFAULT_ENDPOINTS, ...endpoints };
        this.#requestHandler = this.buildRequestHandler();
        this.#nonce = {};
        this.#codeChallenges = new Map();
    }
    get issuer() {
        return this.#issuer;
    }
    async buildToken(req, expiresIn, scopesOrTransform) {
        this.issuer.once(types_internals_1.InternalEvents.BeforeSigning, (token) => {
            this.emit(types_1.Events.BeforeTokenSigning, token, req);
        });
        return await this.issuer.buildToken({ scopesOrTransform, expiresIn });
    }
    get requestHandler() {
        return this.#requestHandler;
    }
    buildRequestHandler = () => {
        const app = (0, express_1.default)();
        app.disable('x-powered-by');
        app.use(express_1.default.json());
        app.use((0, cors_1.default)());
        app.get(this.#endpoints.wellKnownDocument, this.openidConfigurationHandler);
        app.get(this.#endpoints.jwks, this.jwksHandler);
        app.post(this.#endpoints.token, express_1.default.urlencoded({ extended: false }), this.tokenHandler);
        app.get(this.#endpoints.authorize, this.authorizeHandler);
        app.get(this.#endpoints.userinfo, this.userInfoHandler);
        app.post(this.#endpoints.revoke, this.revokeHandler);
        app.get(this.#endpoints.endSession, this.endSessionHandler);
        app.post(this.#endpoints.introspect, this.introspectHandler);
        return app;
    };
    openidConfigurationHandler = (_req, res) => {
        (0, helpers_1.assertIsString)(this.issuer.url, 'Unknown issuer url.');
        const normalizedIssuerUrl = trimPotentialTrailingSlash(this.issuer.url);
        const openidConfig = {
            issuer: this.issuer.url,
            token_endpoint: `${normalizedIssuerUrl}${this.#endpoints.token}`,
            authorization_endpoint: `${normalizedIssuerUrl}${this.#endpoints.authorize}`,
            userinfo_endpoint: `${normalizedIssuerUrl}${this.#endpoints.userinfo}`,
            token_endpoint_auth_methods_supported: ['none'],
            jwks_uri: `${normalizedIssuerUrl}${this.#endpoints.jwks}`,
            response_types_supported: ['code'],
            grant_types_supported: [
                'client_credentials',
                'authorization_code',
                'password',
            ],
            token_endpoint_auth_signing_alg_values_supported: ['RS256'],
            response_modes_supported: ['query'],
            id_token_signing_alg_values_supported: ['RS256'],
            revocation_endpoint: `${normalizedIssuerUrl}${this.#endpoints.revoke}`,
            subject_types_supported: ['public'],
            end_session_endpoint: `${normalizedIssuerUrl}${this.#endpoints.endSession}`,
            introspection_endpoint: `${normalizedIssuerUrl}${this.#endpoints.introspect}`,
            code_challenge_methods_supported: helpers_1.supportedPkceAlgorithms,
        };
        return res.json(openidConfig);
    };
    jwksHandler = (_req, res) => {
        return res.json({ keys: this.issuer.keys.toJSON() });
    };
    tokenHandler = async (req, res, next) => {
        try {
            const tokenTtl = helpers_1.defaultTokenTtl;
            res.set({ 'Cache-Control': 'no-store', Pragma: 'no-cache' });
            let xfn;
            (0, helpers_1.assertIsValidTokenRequest)(req.body);
            if ('code_verifier' in req.body && 'code' in req.body) {
                try {
                    const code = req.body.code;
                    const verifier = req.body['code_verifier'];
                    const savedCodeChallenge = this.#codeChallenges.get(code);
                    if (savedCodeChallenge === undefined) {
                        throw new node_assert_1.AssertionError({ message: 'code_challenge required' });
                    }
                    this.#codeChallenges.delete(code);
                    if (!(0, helpers_1.isValidPkceCodeVerifier)(verifier)) {
                        throw new node_assert_1.AssertionError({
                            message: "Invalid 'code_verifier'. The verifier does not conform with the RFC7636 spec. Ref: https://datatracker.ietf.org/doc/html/rfc7636#section-4.1",
                        });
                    }
                    const doesVerifierMatchCodeChallenge = await (0, helpers_1.pkceVerifierMatchesChallenge)(verifier, savedCodeChallenge);
                    if (!doesVerifierMatchCodeChallenge) {
                        throw new node_assert_1.AssertionError({
                            message: 'code_verifier provided does not match code_challenge',
                        });
                    }
                }
                catch (e) {
                    return res.status(400).json({
                        error: 'invalid_request',
                        error_description: e.message,
                    });
                }
            }
            const reqBody = req.body;
            let { scope } = reqBody;
            const { aud } = reqBody;
            switch (req.body.grant_type) {
                case 'client_credentials':
                    xfn = (_header, payload) => {
                        Object.assign(payload, { scope, aud });
                    };
                    break;
                case 'password':
                    xfn = (_header, payload) => {
                        Object.assign(payload, {
                            sub: reqBody.username,
                            amr: ['pwd'],
                            scope,
                        });
                    };
                    break;
                case 'authorization_code':
                    scope = scope ?? 'dummy';
                    xfn = (_header, payload) => {
                        Object.assign(payload, { sub: 'johndoe', amr: ['pwd'], scope });
                    };
                    break;
                case 'refresh_token':
                    scope = scope ?? 'dummy';
                    xfn = (_header, payload) => {
                        Object.assign(payload, { sub: 'johndoe', amr: ['pwd'], scope });
                    };
                    break;
                default:
                    return res.status(400).json({ error: 'invalid_grant' });
            }
            const token = await this.buildToken(req, tokenTtl, xfn);
            const body = {
                access_token: token,
                token_type: 'Bearer',
                expires_in: tokenTtl,
                scope,
            };
            if (req.body.grant_type !== 'client_credentials') {
                const credentials = (0, basic_auth_1.default)(req);
                const clientId = credentials ? credentials.name : req.body.client_id;
                const xfn = (_header, payload) => {
                    Object.assign(payload, { sub: 'johndoe', aud: clientId });
                    if (reqBody.code !== undefined && this.#nonce[reqBody.code]) {
                        Object.assign(payload, { nonce: this.#nonce[reqBody.code] });
                        delete this.#nonce[reqBody.code];
                    }
                };
                body['id_token'] = await this.buildToken(req, tokenTtl, xfn);
                body['refresh_token'] = (0, node_crypto_1.randomUUID)();
            }
            const tokenEndpointResponse = { body, statusCode: 200 };
            this.emit(types_1.Events.BeforeResponse, tokenEndpointResponse, req);
            return res
                .status(tokenEndpointResponse.statusCode)
                .json(tokenEndpointResponse.body);
        }
        catch (e) {
            return next(e);
        }
    };
    authorizeHandler = (req, res) => {
        const code = (0, node_crypto_1.randomUUID)();
        const { nonce, scope, redirect_uri: redirectUri, response_type: responseType, state, code_challenge, code_challenge_method, } = req.query;
        (0, helpers_1.assertIsString)(redirectUri, 'Invalid redirectUri type');
        (0, helpers_1.assertIsStringOrUndefined)(nonce, 'Invalid nonce type');
        (0, helpers_1.assertIsStringOrUndefined)(scope, 'Invalid scope type');
        (0, helpers_1.assertIsStringOrUndefined)(state, 'Invalid state type');
        (0, helpers_1.assertIsStringOrUndefined)(code_challenge, 'Invalid code_challenge type');
        (0, helpers_1.assertIsStringOrUndefined)(code_challenge_method, 'Invalid code_challenge_method type');
        const url = new node_url_1.URL(redirectUri);
        if (responseType === 'code') {
            if (code_challenge) {
                const codeChallengeMethod = code_challenge_method ?? 'plain';
                (0, helpers_1.assertIsString)(codeChallengeMethod, "Invalid 'code_challenge_method' type");
                if (!helpers_1.supportedPkceAlgorithms.includes(codeChallengeMethod)) {
                    return res.status(400).json({
                        error: 'invalid_request',
                        error_description: `Unsupported code_challenge method ${codeChallengeMethod}. The following code_challenge_method are supported: ${helpers_1.supportedPkceAlgorithms.join(', ')}`,
                    });
                }
                this.#codeChallenges.set(code, {
                    challenge: code_challenge,
                    method: codeChallengeMethod,
                });
            }
            if (nonce !== undefined) {
                this.#nonce[code] = nonce;
            }
            url.searchParams.set('code', code);
        }
        else {
            url.searchParams.set('error', 'unsupported_response_type');
            url.searchParams.set('error_description', 'The authorization server does not support obtaining an access token using this response_type.');
        }
        if (state) {
            url.searchParams.set('state', state);
        }
        const authorizeRedirectUri = { url };
        this.emit(types_1.Events.BeforeAuthorizeRedirect, authorizeRedirectUri, req);
        return res.redirect(url.href);
    };
    userInfoHandler = (req, res) => {
        const userInfoResponse = {
            body: { sub: 'johndoe' },
            statusCode: 200,
        };
        this.emit(types_1.Events.BeforeUserinfo, userInfoResponse, req);
        return res.status(userInfoResponse.statusCode).json(userInfoResponse.body);
    };
    revokeHandler = (req, res) => {
        const revokeResponse = { statusCode: 200 };
        this.emit(types_1.Events.BeforeRevoke, revokeResponse, req);
        return res.status(revokeResponse.statusCode).send('');
    };
    endSessionHandler = (req, res) => {
        (0, helpers_1.assertIsString)(req.query['post_logout_redirect_uri'], 'Invalid post_logout_redirect_uri type');
        const postLogoutRedirectUri = {
            url: new node_url_1.URL(req.query['post_logout_redirect_uri']),
        };
        this.emit(types_1.Events.BeforePostLogoutRedirect, postLogoutRedirectUri, req);
        return res.redirect(postLogoutRedirectUri.url.href);
    };
    introspectHandler = (req, res) => {
        const introspectResponse = {
            body: { active: true },
            statusCode: 200,
        };
        this.emit(types_1.Events.BeforeIntrospect, introspectResponse, req);
        return res
            .status(introspectResponse.statusCode)
            .json(introspectResponse.body);
    };
}
exports.OAuth2Service = OAuth2Service;
const trimPotentialTrailingSlash = (url) => {
    return url.endsWith('/') ? url.slice(0, -1) : url;
};

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JWKStore = void 0;
const node_crypto_1 = require("node:crypto");
const node_assert_1 = require("node:assert");
const jose_1 = require("jose");
const helpers_1 = require("./helpers");
const generateRandomKid = () => {
    return (0, node_crypto_1.randomBytes)(40).toString('hex');
};
const RsaPrivateFieldsRemover = (jwk) => {
    const x = { ...jwk };
    delete x.d;
    delete x.p;
    delete x.q;
    delete x.dp;
    delete x.dq;
    delete x.qi;
    return x;
};
const EcdsaPrivateFieldsRemover = (jwk) => {
    const x = { ...jwk };
    delete x.d;
    return x;
};
const EddsaPrivateFieldsRemover = (jwk) => {
    const x = { ...jwk };
    delete x.d;
    return x;
};
const privateToPublicTransformerMap = {
    RS256: RsaPrivateFieldsRemover,
    RS384: RsaPrivateFieldsRemover,
    RS512: RsaPrivateFieldsRemover,
    PS256: RsaPrivateFieldsRemover,
    PS384: RsaPrivateFieldsRemover,
    PS512: RsaPrivateFieldsRemover,
    ES256: EcdsaPrivateFieldsRemover,
    ES256K: EcdsaPrivateFieldsRemover,
    ES384: EcdsaPrivateFieldsRemover,
    ES512: EcdsaPrivateFieldsRemover,
    EdDSA: EddsaPrivateFieldsRemover,
};
const supportedAlgs = Object.keys(privateToPublicTransformerMap);
function normalizeKeyKid(jwk, opts) {
    (0, helpers_1.assertIsPlainObject)(jwk, 'Invalid jwk format');
    if (jwk['kid'] !== undefined) {
        return;
    }
    if (opts !== undefined && opts.kid !== undefined) {
        jwk['kid'] = opts.kid;
    }
    else {
        jwk['kid'] = generateRandomKid();
    }
}
class JWKStore {
    #keyRotator;
    constructor() {
        this.#keyRotator = new KeyRotator();
    }
    async generate(alg, opts) {
        const generateOpts = opts !== undefined && opts.crv !== undefined ? { crv: opts.crv } : {};
        const pair = await (0, jose_1.generateKeyPair)(alg, generateOpts);
        const joseJwk = await (0, jose_1.exportJWK)(pair.privateKey);
        normalizeKeyKid(joseJwk, opts);
        joseJwk.alg = alg;
        const jwk = joseJwk;
        this.#keyRotator.add(jwk);
        return jwk;
    }
    async add(maybeJwk) {
        const tempJwk = { ...maybeJwk };
        normalizeKeyKid(tempJwk);
        if (tempJwk.alg === undefined) {
            throw new Error('Unspecified JWK "alg" property');
        }
        if (!supportedAlgs.includes(tempJwk.alg)) {
            throw new Error(`Unsupported JWK "alg" value ("${tempJwk.alg}")`);
        }
        const jwk = tempJwk;
        const privateKey = await (0, jose_1.importJWK)(jwk);
        if (!(privateKey instanceof node_crypto_1.KeyObject) || privateKey.type !== 'private') {
            throw new Error(`Invalid JWK type. No "private" key related data has been found.`);
        }
        this.#keyRotator.add(jwk);
        return jwk;
    }
    get(kid) {
        return this.#keyRotator.next(kid);
    }
    toJSON(includePrivateFields = false) {
        return this.#keyRotator.toJSON(includePrivateFields);
    }
}
exports.JWKStore = JWKStore;
class KeyRotator {
    #keys = [];
    add(key) {
        const pos = this.findNext(key.kid);
        if (pos > -1) {
            this.#keys.splice(pos, 1);
        }
        this.#keys.push(key);
    }
    next(kid) {
        const i = this.findNext(kid);
        if (i === -1) {
            return undefined;
        }
        return this.moveToTheEnd(i);
    }
    toJSON(includePrivateFields) {
        const keys = [];
        for (const key of this.#keys) {
            if (includePrivateFields) {
                keys.push({ ...key });
                continue;
            }
            const cleaner = privateToPublicTransformerMap[key.alg];
            if (cleaner === undefined) {
                throw new Error(`Unsupported algo '{key.alg}'`);
            }
            keys.push(cleaner(key));
        }
        return keys;
    }
    findNext(kid) {
        if (this.#keys.length === 0) {
            return -1;
        }
        if (kid === undefined) {
            return 0;
        }
        return this.#keys.findIndex((x) => x.kid === kid);
    }
    moveToTheEnd(i) {
        const [key] = this.#keys.splice(i, 1);
        if (key === undefined) {
            throw new node_assert_1.AssertionError({
                message: 'Unexpected error. key is supposed to exist',
            });
        }
        this.#keys.push(key);
        return key;
    }
}

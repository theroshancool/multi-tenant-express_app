"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpServer = void 0;
const node_http_1 = require("node:http");
const node_https_1 = require("node:https");
const node_net_1 = require("node:net");
const node_url_1 = require("node:url");
const helpers_1 = require("./helpers");
class HttpServer {
    #server;
    #isSecured;
    constructor(requestListener, options) {
        this.#isSecured = false;
        if (options?.key && options?.cert) {
            this.#server = (0, node_https_1.createServer)(options, requestListener);
            this.#isSecured = true;
        }
        else {
            this.#server = (0, node_http_1.createServer)(requestListener);
        }
    }
    get listening() {
        return this.#server.listening;
    }
    address() {
        if (!this.listening) {
            throw new Error('Server is not started.');
        }
        const address = this.#server.address();
        (0, helpers_1.assertIsAddressInfo)(address);
        return address;
    }
    async start(port, host) {
        if (this.listening) {
            throw new Error('Server has already been started.');
        }
        return new Promise((resolve, reject) => {
            this.#server
                .listen(port, host)
                .on('listening', resolve)
                .on('error', reject);
        });
    }
    async stop() {
        if (!this.listening) {
            throw new Error('Server is not started.');
        }
        return new Promise((resolve, reject) => {
            this.#server.close((err) => {
                if (err) {
                    return reject(err);
                }
                return resolve();
            });
        });
    }
    buildIssuerUrl(host, port) {
        const url = new node_url_1.URL(`${this.#isSecured ? 'https' : 'http'}://localhost:${port}`);
        if (host && !coversLocalhost(host)) {
            url.hostname = host.includes(':') ? `[${host}]` : host;
        }
        return url.origin;
    }
}
exports.HttpServer = HttpServer;
const coversLocalhost = (address) => {
    switch ((0, node_net_1.isIP)(address)) {
        case 4:
            return address === '0.0.0.0' || address.startsWith('127.');
        case 6:
            return address === '::' || address === '::1';
        default:
            return false;
    }
};

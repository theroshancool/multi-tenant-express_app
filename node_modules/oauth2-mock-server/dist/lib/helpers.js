"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPKCECodeChallenge = exports.supportedPkceAlgorithms = exports.createPKCEVerifier = exports.isValidPkceCodeVerifier = exports.readJsonFromFile = exports.defaultTokenTtl = void 0;
exports.assertIsString = assertIsString;
exports.assertIsStringOrUndefined = assertIsStringOrUndefined;
exports.assertIsAddressInfo = assertIsAddressInfo;
exports.assertIsPlainObject = assertIsPlainObject;
exports.pkceVerifierMatchesChallenge = pkceVerifierMatchesChallenge;
exports.assertIsValidTokenRequest = assertIsValidTokenRequest;
exports.shift = shift;
const node_assert_1 = require("node:assert");
const node_fs_1 = require("node:fs");
const node_crypto_1 = require("node:crypto");
const is_plain_object_1 = require("is-plain-object");
exports.defaultTokenTtl = 3600;
function assertIsString(input, errorMessage) {
    if (typeof input !== 'string') {
        throw new node_assert_1.AssertionError({ message: errorMessage });
    }
}
function assertIsStringOrUndefined(input, errorMessage) {
    if (typeof input !== 'string' && input !== undefined) {
        throw new node_assert_1.AssertionError({ message: errorMessage });
    }
}
function assertIsAddressInfo(input) {
    if (input === null || typeof input === 'string') {
        throw new node_assert_1.AssertionError({ message: 'Unexpected address type' });
    }
}
function assertIsPlainObject(obj, errMessage) {
    if (!(0, is_plain_object_1.isPlainObject)(obj)) {
        throw new node_assert_1.AssertionError({ message: errMessage });
    }
}
async function pkceVerifierMatchesChallenge(verifier, challenge) {
    const generatedChallenge = await (0, exports.createPKCECodeChallenge)(verifier, challenge.method);
    return generatedChallenge === challenge.challenge;
}
function assertIsValidTokenRequest(body) {
    assertIsPlainObject(body, 'Invalid token request body');
    if ('scope' in body) {
        assertIsString(body['scope'], "Invalid 'scope' type");
    }
    assertIsString(body['grant_type'], "Invalid 'grant_type' type");
    if ('code' in body) {
        assertIsString(body['code'], "Invalid 'code' type");
    }
    if ('aud' in body) {
        const aud = body['aud'];
        if (Array.isArray(aud)) {
            aud.forEach((a) => assertIsString(a, "Invalid 'aud' type"));
        }
        else {
            assertIsString(aud, "Invalid 'aud' type");
        }
    }
}
function shift(arr) {
    if (arr.length === 0) {
        throw new node_assert_1.AssertionError({ message: 'Empty array' });
    }
    const val = arr.shift();
    if (val === undefined) {
        throw new node_assert_1.AssertionError({ message: 'Empty value' });
    }
    return val;
}
const readJsonFromFile = (filepath) => {
    const content = (0, node_fs_1.readFileSync)(filepath, 'utf8');
    const maybeJson = JSON.parse(content);
    assertIsPlainObject(maybeJson, `File "${filepath}" doesn't contain a properly JSON serialized object.`);
    return maybeJson;
};
exports.readJsonFromFile = readJsonFromFile;
const isValidPkceCodeVerifier = (verifier) => {
    const PKCE_CHALLENGE_REGEX = /^[A-Za-z0-9\-._~]{43,128}$/;
    return PKCE_CHALLENGE_REGEX.test(verifier);
};
exports.isValidPkceCodeVerifier = isValidPkceCodeVerifier;
const createPKCEVerifier = () => {
    const randomBytes = node_crypto_1.webcrypto.getRandomValues(new Uint8Array(32));
    return Buffer.from(randomBytes).toString('base64url');
};
exports.createPKCEVerifier = createPKCEVerifier;
exports.supportedPkceAlgorithms = ['plain', 'S256'];
const createPKCECodeChallenge = async (verifier = (0, exports.createPKCEVerifier)(), algorithm = 'plain') => {
    let challenge;
    switch (algorithm) {
        case 'plain': {
            challenge = verifier;
            break;
        }
        case 'S256': {
            const buffer = await node_crypto_1.webcrypto.subtle.digest('SHA-256', new TextEncoder().encode(verifier));
            challenge = Buffer.from(buffer).toString('base64url');
            break;
        }
        default:
            throw new Error(`Unsupported PKCE method ("${algorithm}")`);
    }
    return challenge;
};
exports.createPKCECodeChallenge = createPKCECodeChallenge;
